Seamless is essentially a caching machine: transformation results are stored remotely as a result checksum plus the underlying buffer. The checksum goes to the database client and the buffer goes to the buffer/hashserver; repeat submissions reuse cached work.

Normal Seamless lifecycle: construct() → compute() → run(). Construction happens on the client (producing a transformation checksum). Computation can be remote, and run() simply resolves the checksum on the client.

Dask difference: tasks can be submitted before construction finishes. Inputs and transformations themselves can be Dask futures. The goal is to reuse work via deterministic keys when possible, while keeping result buffers hot on workers for nearby dependents.

Case 1: transformation without dependencies (inputs are checksums or values that become checksums). Steps:
- Construct on the client to get the transformation checksum. Check the remote database/cache; on hit, do not submit to Dask.
- On miss, build “fat checksum” futures per input checksum. These run on workers, pull `(checksum, buffer, exc)` from hashserver/buffer cache, and use predictable keys `fat-checksum-{checksum.hex()}`. Creating the future does not force execution. A weak/strong cache keeps these futures alive; strong entries expire ~10s after last access (refreshed on access). Default-task-duration: “fast”.
- Build three futures keyed deterministically with the transformation checksum (e.g., `base-{tf_checksum}`, `fat-{tf_checksum}`, `thin-{tf_checksum}`); if already running, Dask will reuse them.
  - Base future (worker): awaits fat inputs, re-checks cache, and either returns `(tf_checksum, result_checksum, None, None)` on hit or runs the transformation, writes checksum+buffer to db/hashserver, and returns `(tf_checksum, result_checksum, result_buffer, None)`; on error `(tf_checksum, None, None, exc)`. The result buffer intentionally stays in worker memory for near-term dependents. Default-task-duration: “fast” (but moves/holds buffer).
  - Fat future (worker): depends on base. If base already returned a buffer it forwards `(result_checksum, result_buffer, exc)`; if base hit cache, it awaits the result’s fat-checksum future and forwards that result. Two timing paths: instantaneous when piggybacking on base, slower when fetching from hashstore/NFS. Use a small nonzero default duration to cover the slower path.
  - Thin future (worker): depends on base, returns `(tf_checksum, result_checksum, exc)` without the buffer. Default-task-duration: “fast”.
- A transformation_checksum→(base, fat, thin) cache mirrors the fat-checksum cache; entries are reconstructed as needed and refreshed at the end of computation. .compute() runs the thin future; on exc it sets a RemoteException, otherwise it records result_checksum and registers a dummy task under the fat-checksum key that returns the fat future.

Case 2: transformation with dependencies (some inputs are Transformation instances).
- construct() semantics unchanged, but compute() no longer auto-calls construct().
- When compute() runs: if any dependency already has an exception, set “Dependency has an exception.” Prefer dependencies that already have their (base, fat, thin) triple alive in Dask; otherwise, if a dependency has completed, replace it with its result checksum. If all deps become concrete, fall back to Case 1. If a dep is unknown to Dask and not completed, rebuild its triple.
- Build a transformation dict with fat checksum futures for concrete inputs and fat Transformation futures (from their triples) for dependent transforms. Submit three futures analogous to Case 1:
  - Base future (worker): performs construction once dep checksums are known, checks cache, and on hit returns `(tf_checksum, result_checksum, None, None)`. If it misses, it learns the deterministic key for the Case 1 base task. A worker cannot truly alias scheduler keys, but it may submit `K2` from within the task using `get_client()` and `client.submit(lambda x: x, current_future, key=K2)` to let later tasks keyed `K2` reuse the running work; this is not a scheduler-level alias and only affects tasks submitted after `K2` is registered (co-location not guaranteed unless you pin the worker). It then runs the transformation, writes checksum+buffer, and returns `(tf_checksum, result_checksum, result_buffer, None)` or an exc tuple.
  - Fat/thin futures behave as in Case 1. Because the transformation checksum is initially unknown, the (base, fat, thin) triple cannot be cached by checksum.

Keying and caches:
- Deterministic keys should incorporate anything that changes semantics (e.g., scratch/meta/resources) to avoid unintended cross-client reuse/cancellation.
- Keep strong references to long-running futures; the 10s strong-cache TTL is refreshed on access, but if the client drops references, Dask may cancel in-flight work.
- Nested client submissions from workers should avoid blocking; if awaiting nested futures, use `worker_client(secede=True)` to free the worker thread.
